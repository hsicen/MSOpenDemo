package me.hsicen.msopendemoimport android.app.Activityimport android.app.Applicationimport android.util.Logimport androidx.compose.runtime.getValueimport androidx.compose.runtime.mutableStateOfimport androidx.compose.runtime.setValueimport androidx.lifecycle.AndroidViewModelimport com.microsoft.graph.models.Eventimport com.microsoft.identity.client.IAuthenticationResultimport com.microsoft.identity.client.exception.MsalClientExceptionimport com.microsoft.identity.client.exception.MsalServiceExceptionimport com.microsoft.identity.client.exception.MsalUiRequiredExceptionimport me.hsicen.msopendemo.model.AuthenticationHelperimport me.hsicen.msopendemo.model.GraphHelperimport me.hsicen.msopendemo.model.GraphToIanaimport me.hsicen.msopendemo.ui.theme.WeComposeThemeimport java.time.DayOfWeekimport java.time.ZoneIdimport java.time.ZonedDateTimeimport java.time.temporal.ChronoUnitimport java.time.temporal.TemporalAdjustersimport java.util.Dateimport com.microsoft.graph.models.User as MUser/** * 作者：hsicen  12/8/21 22:55 * 邮箱：codinghuang@163.com * 作用： * 描述：数据 maintain */class WeViewModel(private val app: Application) : AndroidViewModel(app) {  var theme by mutableStateOf(WeComposeTheme.Theme.Light)  var mUser: MUser? by mutableStateOf(null)  private var mAuthHelper: AuthenticationHelper? = null  private var mSignedIn = false  private var isInSign = false  fun initSdk(act: Activity) {    isInSign = true    AuthenticationHelper.getInstance(app)      .thenAccept { authHelper ->        mAuthHelper = authHelper        if (mSignedIn.not()) {          doSilentSign(act, false)        } else isInSign = false      }.exceptionally {        println("hsc -> Error create auth helper: ${it.stackTrace}")        null      }  }  private fun doSilentSign(act: Activity, interrupt: Boolean) {    mAuthHelper?.let { helper ->      helper.acquireTokenSilently()        .thenAccept {          handleSignSuccess(it)        }.exceptionally {          val cause = it.cause          if (cause is MsalUiRequiredException) {            Log.d("hsc", "Interactive login required")            if (interrupt) doInteractiveSign(act)          } else if (cause is MsalClientException) {            if (cause.errorCode == "no_current_account" ||              cause.errorCode == "no_account_found"            ) {              Log.d("hsc", "No current account, interactive login required")              if (interrupt) doInteractiveSign(act)            }          } else handleSignInFailure(cause)          isInSign = false          null        }    }  }  private fun doInteractiveSign(act: Activity) {    mAuthHelper?.acquireTokenInteractively(act)      ?.thenAccept { handleSignSuccess(it) }      ?.exceptionally {        handleSignInFailure(it)        isInSign = false        null      }  }  private fun handleSignSuccess(it: IAuthenticationResult?) {    val result = it ?: return    val token = result.accessToken    Log.d("hsc", "Access token is $token")    val helper = GraphHelper.instance    helper.getUser()      .thenAccept { user ->        Log.d("hsc", "Get user info success: $user")        mUser = user        isInSign = false        mSignedIn = true      }.exceptionally {        Log.d("hsc", "Get user info failed: $it")        isInSign = false        mSignedIn = false        null      }  }  private fun handleSignInFailure(cause: Throwable?) {    when (cause) {      is MsalServiceException -> {        // Exception when communicating with the auth server, likely config issue        Log.e("hsc", "Service error authenticating", cause)      }      is MsalClientException -> {        // Exception inside MSAL, more info inside MsalError.java        Log.e("hsc", "Client error authenticating", cause)      }      else -> {        Log.e("hsc", "Unhandled exception authenticating", cause)      }    }  }  fun signIn(act: Activity) {    isInSign = true    doSilentSign(act, true)  }  fun signOut() {    mAuthHelper?.signOut()    mSignedIn = false    mUser = null  }  val mEventList = ArrayList<Event>()  private fun addEvents() {    val jsonEvents = GraphHelper.instance.serializeObject(mEventList)    Log.d("hsc  日程信息", jsonEvents)  }  fun queryEvent() {    val instance = GraphHelper.instance    val timeZone = mUser?.mailboxSettings?.timeZone ?: "China Standard Time"    val tzId = GraphToIana.getZoneIdFromWindows(timeZone)    val startOfWeek: ZonedDateTime = ZonedDateTime.now(tzId)      .with(TemporalAdjusters.previousOrSame(DayOfWeek.SUNDAY))      .truncatedTo(ChronoUnit.DAYS)      .withZoneSameInstant(ZoneId.of("UTC"))    val endOfWeek = startOfWeek.plusDays(7)    instance.getCalendarEvent(startOfWeek, endOfWeek, timeZone)      ?.thenAccept { eventList ->        mEventList.clear()        mEventList.addAll(eventList)        addEvents()      }?.exceptionally {        Log.e("hsc", "获取日程出错", it)        null      }  }  fun createEvent() {    val subject = "创建日程：${Date()}"    val start = ZonedDateTime.now()    val end = start.plusDays(1)    val timeZone = mUser?.mailboxSettings?.timeZone ?: "China Standard Time"    val attends = listOf("865632811@qq.com", "hsc@hsicen.top")    val content = "测试日程内容 : ${Date()}"    GraphHelper.instance      .creatEvent(subject, start, end, timeZone, attends, content)      ?.thenAccept {        Log.d("hsc", "创建日程成功: $it")        queryEvent()      }?.exceptionally {        Log.d("hsc", "创建日程失败: $it")        null      }  }}